#!/usr/bin/perl

# index.pl
# CGI script for main Web page for BAER DB, Moscow Forestry Sciences 
# Laboratory. By Conrad Albrecht (CMA) 2013.06.06.

=pod
############################### JAVASCRIPT TYPES ###############################
This section documents our JavaScript "types" since JavaScript doesn't support
them in actual code.

TYPE:  MarkerData.  -CMA 2014.01.09.

NOTES:  MarkerData data literals are generated by our Perl code, and used by our
client-side JavaScript code to create and handle markers on our map in map view.

FIELDS:
	lat_lng:  google.maps.LatLng.
	title:    string.

	projs:  int[].  Array of project handles for the projects associated with
		this marker.

=cut

use strict;
use warnings;

############################## PROFILING SUPPORT ###############################

require CGI;

# Diagnostics flag.  -CMA 2013.07.22.	
#our $g_Diag = CGI::url_param( "diag" );

# For profiling.  -CMA 2013.08.28.
#require Time::HiRes;
#our $g_Time01 = Time::HiRes::gettimeofday() if $g_Diag;

################################# "#INCLUDES" ##################################

require "PageCommon.pl";	# For BwdPages pkg.  -CMA 2013.11.15.
require "Query.pl";		# For TheProjs pkg.  -CMA 2013.08.13.
require "ShowProj.pl";		# For ShowProj pkg.  -CMA 2014.01.14.

################################# GLOBAL DATA ##################################

# This is a place that our code running not in a context that can display
# diagnostic messages, can save a message to be displayed later.
# -CMA 2013.07.25.
#our $g_DeferredDiagMsg = "";

# Temp code for testing in-progress new feature.  -CMA 2014.01.03.
#our $g_GroupMarkers = CGI::url_param( "group" );

################################### "MAIN()" ###################################

# Because Perl has no compile-time init.
Treatment::Init();
BaerProj::Init();
TheProjs::Init();
ShowProj::Init();	# -CMA 2014.01.14.

TheBwdPageState::Load();	# Accesses our URL params.
TheProjs::Load();		# Load from file the data we'll show on the Web page.
Bwd::PrintHttpResponse();	# Generate the Web page.

# End "Main" script.  -CMA 2013.07.25.

###############################################################################
###############################################################################
# PACKAGE:  Bwd.  -CMA 2013.08.02.

# Catch-all package to avoid implicitly using main::, which caused nasty bugs.
{	package Bwd;

###############################################################################
# SUB:  Bwd::GetLatLonInputsHtml.

# ACTION:  Generates the HTML for the Latitude & Longitude input boxes in our
# Search form.
sub GetLatLonInputsHtml {
	my $rPageState = TheBwdPageState::GetC();

	# Prefill the boxes from previous page state (URL params), if any.
	my $DegN       = BwdPageState::DegN( $rPageState );
	my $DnValAttr  = length( $DegN ) ? " value='$DegN'" : "";
	my $DegW       = BwdPageState::DegW( $rPageState );
	my $DwValAttr  = length( $DegW ) ? " value='$DegW'" : "";

	# I'm keeping this JavaScript code close to the elements it modifies.  It
	# just fills the input boxes and is called by our location.pl popup window.
	return "
<script type='text/javascript'>
	function TakeDistOrigin( lat, lon ) {
		// 3 decimal places is ~100 yards, which is plenty close for finding
		// fires and reduces clutter on the page.
		document.getElementById( 'inDn' ).value = lat.toFixed( 3 );
		document.getElementById( 'inDw' ).value = lon.toFixed( 3 );
	}
</script>

<!-- Note that 'placeholder' works on modern Chrome but not IE 8.
															-CMA 2014.02.03. -->
<input id='inDn' type='text' name='dN' style='width:4em' placeholder='00.000'
														$DnValAttr />&deg; N,
<input id='inDw' type='text' name='dW' style='width:4em' placeholder='000.000'
															$DwValAttr />&deg; W
	";
}	# Bwd::GetLatLonInputsHtml.  -CMA 2013.11.21.

###############################################################################
# SUB:  Bwd::ParamsToHiddenInputs.
# ACTION:  Generates a series of hidden input HTML element strings.
# PARAMS:  $raParams is a ref to an array of alternating param names and values.
sub ParamsToHiddenInputs { my( $raParams ) = @_;
	my $Ret = "";

	for( 0 .. @$raParams / 2 - 1 ) {
		$Ret .=
				"<input type='hidden' name='" . $raParams->[ $_ * 2 ] .
						"' value='" . $raParams->[ $_ * 2 + 1 ] . "' />\n"; }

	return $Ret;
}	# Bwd::ParamsToHiddenInputs.  -CMA 2013.07.31.

###############################################################################
# SUB:  Bwd::PrintDatesInputLine.

# ACTION:  Generates the HTML string for the line in our Search form which gets
# the date range from the user.
sub PrintDatesInputLine {
	# Note that "placeholder" works in modern Chrome but not in IE 8.
	# -CMA 2014.02.03.
	my $c_CommonAttrs =
			"style='width:7em'
			title='YYYY-MM-DD, or 3-letter month e.g. 2010-JUN-21, or blank'
			placeholder='YYYY-MM-DD'";

	my $StartDate     = TheBwdPageState::StartDate();
	my $EndDate       = TheBwdPageState::EndDate();
	my $StartDateAttr = $StartDate ? "value='$StartDate'" : "";
	my $EndDateAttr   = $EndDate   ? "value='$EndDate'"   : "";

	print( "
From date <input type='text' name='start_date' $StartDateAttr $c_CommonAttrs />
		to <input type='text' name='end_date' $EndDateAttr $c_CommonAttrs />
		(YYYY-MM-DD, or blank)<br />
	" );
}	# Bwd::PrintDatesInputLine.  -CMA 2013.08.26.

###############################################################################
# SUB:  Bwd::PrintFoundProjsDescr.

# ACTION:  Prints "Found XXX BAER reports with this search:" and then a
# description of the filter criteria; may take several lines.
sub PrintFoundProjsDescr { my ( $raProjs ) = @_;
	my $rPageState = TheBwdPageState::GetC();

	print( "Found " . @$raProjs . " BAER reports with this search:<br />" );

	# We set this below, then use it to tell the user which type of locations
	# we're filtering for.  Anything but "state" or "rgn" means "forest".
	my $LocType = "";

	# Set $LocType.  Since we are describing the *existing* search, we must use
	# actual forest/state/rgn params, if any, rather than the loc_type param,
	# which really only controls what's in the locations select box for the
	# *next* search.  We only support a single loc type per request, so if the
	# user hacks a mixed-type URL, they just get GIGO.
	if( BwdPageState::Forests( $rPageState ) ) {
		# If we have requested forest(s), then leave $LocType empty, which means
		# forests.
	}
	elsif( BwdPageState::States( $rPageState ) ) {
		$LocType = "state"; }
	elsif( BwdPageState::Regions( $rPageState ) ) {
		$LocType = "rgn"; }
	else {
		# If we aren't actually filtering for any locations, then we can use the
		# user's chosen "next search location type" to tell the user which
		# location type we're *not* currently filtering for.
		$LocType = BwdPageState::LocType( $rPageState ); }

	# Kill Perl eq-null warning.  -CMA 2014.02.03.
	$LocType = "" unless defined( $LocType );

	# We set these below, then use them to tell the user which locations we're
	# filtering for.
	my $LocTypeLabel;
	my @ReqLocs;

	# Set $LocTypeLabel & @ReqLocs.
	if( "state" eq $LocType ) {
		$LocTypeLabel = "States";
		@ReqLocs      = BwdPageState::States( $rPageState );
	}
	elsif( "rgn" eq $LocType ) {
		$LocTypeLabel = "Regions";

		# Tested by Test140205_1247.  -CMA 2014.02.05.
		@ReqLocs = BwdPageState::Regions( $rPageState );

		# @ReqLocs now contains a list of region #s, e.g. ( 2, 3 ).  Used as-is,
		# for a single region, e.g. region 2, this would produce the description
		# "Regions: 2", which is confusing because it looks like a *count* of
		# regions.  So, prepend "Region", which will produce the description
		# "Regions: Region 2" or "Regions: Region 2, Region 3".
		$_ = "Region $_" for @ReqLocs;	
	}
	else {
		$LocTypeLabel = "Forests";
		@ReqLocs      = BwdPageState::Forests( $rPageState );
	}

	# Print the line describing the requested locations.
	PrintSelectedItemsLine( $LocTypeLabel, \@ReqLocs );

	my @ReqTmts = TheBwdPageState::RequestedTreatments();

	PrintSelectedItemsLine( "Treatments", \@ReqTmts );

	my $StartDate = TheBwdPageState::StartDate();
	my $EndDate   = TheBwdPageState::EndDate();

	# If we're filtering on a date range, print a line describing it.
	if( $StartDate || $EndDate ) {
		my $Phrase;

		if( $StartDate && $EndDate ) {
			$Phrase = "From $StartDate to $EndDate"; }
		elsif ( $StartDate ) {
			$Phrase = "On or after $StartDate"; }
		else {
			$Phrase = "On or before $EndDate"; }

		print( "<span class='SpanIndent'></span>$Phrase<br />\n" );
	}
}	# Bwd::PrintFoundProjsDescr.  -CMA 2013.08.06.

###############################################################################
# SUB:  Bwd::PrintHtmlHead.
sub PrintHtmlHead { my ( $raProjs ) = @_;
	# Our XML DB contains UTF-8-encoded characters which we copy to output, so
	# we definitely need the charset=UTF-8 spec for the browser to show these
	# correctly.  -CMA 2013.07.19.
	print( "
<head>
<meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
<title>RMRS - BAER Burned Area Reports DB</title>

<link rel='stylesheet' type='text/css' href='/BAERTOOLS/baer-db/baer-db.css' />
	" );

	PrintPageStyle();	# -CMA 2013.11.26.

	my $rPageState = TheBwdPageState::GetC();
	my $bMapView   = BwdPageState::IsMapView( $rPageState );

	if( $bMapView ) {	# -CMA 2013.11.26.
		# Include Google Maps API.
		print( "
<script type='text/javascript'
					src='https://maps.googleapis.com/maps/api/js?sensor=false'>
</script> 
		" ); }

	print( "<script type='text/javascript'>\n" );
	PrintOnLoadFunc( $bMapView, $raProjs );		# -CMA 2013.11.27.

	# In map view, print JavaScript functions only used in that view.
	# -CMA 2014.01.02.
	if( $bMapView ) {
		# Create a relink URL with the "proj" params removed, so the code below
		# can add its own "proj" params.
		my $rNoProjsPageState = BwdPageState::Copy( $rPageState );

		BwdPageState::ClearMapProjects( $rNoProjsPageState );

		my $NoProjsUrl = BwdQuery::GetRelinkUrl( $rNoProjsPageState );
		my $OldUrl     = BwdQuery::GetRelinkUrl( $rPageState );

		print( "
// Handler for clicking on a marker in our map.  It regets the page with reports
// for this marker's projects displayed after the map.
function onMarkerClick() {
	var map = this.getMap();

	// Preserve the current map state across the relink by sending these params,
	// which onLoadMapView() will use on reload.
	var sUrl =
			'$NoProjsUrl' + 'mapLat=' + map.getCenter().lat() + '&mapLon=' +
							map.getCenter().lng() + '&mapZoom=' + map.getZoom();

	// Add 'proj' params to show reports for this marker's projects.  The
	// <projs> field was added to <this> marker by onLoadMapView(), and was
	// copied from a MarkerData.projs field.
	for( var i = 0; i < this.projs.length; i++ )
		sUrl += '&proj=' + this.projs[ i ];

	location.assign( sUrl );	// Reget the page.
}

function onMapZoom() {
	// Most browsers, except of course IE, support this.
	var bMost    = ( typeof( pageYOffset ) == 'number' );

	// Get the page's current scroll position.
	var iScrollY = bMost ? pageYOffset : document.documentElement.scrollTop;

	// onLoadMapView() uses these extra params.  We preserve scroll position
	// because we don't want the map jumping away from the mouse every time the
	// user click the zoom buttons.
	var sUrl =
			'$OldUrl" . "mapLat=' + this.getCenter().lat() + '&mapLon=' +
			this.getCenter().lng() + '&mapZoom=' + this.getZoom() + '&scrollY='
			+ iScrollY;

	// Reget the page.  Required because the grouped markers, generated at the
	// server, depend on the changed zoom level.
	location.assign( sUrl );
}
		" );

		PrintOnLoadMap( $raProjs );	# -CMA 2013.12.31.
	}

	print( "</script>\n</head>\n" );
}	# Bwd::PrintHtmlHead.  -CMA 2013.07.25.

###############################################################################
# SUB:  Bwd::PrintHttpResponse.
sub PrintHttpResponse {
	# The projects requested by the user's submission of our Search form, or all
	# of our DB's projects if s/he hasn't searched yet.
	my $raProjs = TheBwdPageState::Filter();	# -CMA 2013.11.27.

	print "Content-type: text/html\n\n";

	# Using DOCTYPE to avoid browsers' quirks mode, e.g. so tables correctly
	# inherit font-size.
	#
	# This print() call is separate so as to use single-quotes around the
	# double-quotes.  -CMA 2013.11.14.
	print( '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
						"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">' );

	print( "<html>\n" );
	PrintHtmlHead( $raProjs );	# -CMA 2013.11.27.
	print( "<body onload='onLoad()'>\n" );
	BwdPages::PrintBanners( "BAER Burned Area Reports DB" );
	print( "<div class='PageContentDiv' style='max-width:70em'>" );

#	print( "Deferred diag message: <br />$g_DeferredDiagMsg<br />" ) if $g_Diag;

	ShowBaerDbContent( $raProjs );	# -CMA 2013.11.27.

	print( "
</div>
</body>
</html>
	" );
}	# Bwd::PrintHttpResponse.  -CMA 2013.07.25.

###############################################################################
# SUB:  Bwd::PrintLocationsSelectDiv.

# ACTION:  Prints the section of our Search form which lets the user choose
# locations to filter on, incl. label, selector for location type (forest,
# state, region), and the select list of actual locations (forests, states, or
# regions).
sub PrintLocationsSelectDiv {
	my $rPageState = TheBwdPageState::GetC();

	# Create relink URLs which, when the user selects a different location type, 
	# will reget the page with that location type active.  The location-type
	# dropdown is not a named form element, and its value is not submitted with
	# the form; rather, we act on the user changing it immediately, because the
	# actual location select list must change immediately.

	my $rLocTypePageState = BwdPageState::Copy( $rPageState );

	BwdPageState::SetLocType( $rLocTypePageState, "forest" );

	my $ForestUrl = BwdQuery::GetRelinkUrl( $rLocTypePageState );

	BwdPageState::SetLocType( $rLocTypePageState, "state" );

	my $StateUrl = BwdQuery::GetRelinkUrl( $rLocTypePageState );

	BwdPageState::SetLocType( $rLocTypePageState, "rgn" );

	my $RgnUrl   = BwdQuery::GetRelinkUrl( $rLocTypePageState );

	# Create selected attributes which will preselect the currently active
	# location type in the location-type dropdown.
	my $LocType  = BwdPageState::LocType( $rPageState );
	my $StateSel = "state" eq $LocType ? " selected='selected'" : "";
	my $RgnSel   = "rgn"   eq $LocType ? " selected='selected'" : "";

	# Tested by Test140207_1121.  -CMA 2014.02.07.
	print( "
<div style='float:left; margin-right:20px'>
	Location, by:

<script type='text/javascript'>
	// The handler for the location-type selector below.
	function OnLocSelChange( sel ) {
		switch( sel.selectedIndex ) {
			case 0:  location.href='$ForestUrl';  break;
			case 1:  location.href='$StateUrl';   break;
			case 2:  location.href='$RgnUrl';     break;
		}
	}
</script>

<!-- Location-type selector. -->
<select onchange='OnLocSelChange( this )' size='1'>
	<option>National Forest</option>
	<option$StateSel>State</option>
	<option$RgnSel>USFS Region</option>
</select><br />
	");

	# Finally, print the actual location select list.
	PrintLocationsSelectElem();

	print( "</div>\n");
}	# Bwd::PrintLocationsSelectDiv.  -CMA 2013.08.06.

###############################################################################
# SUB:  Bwd::PrintLocationsSelectElem.

# ACTION:  Prints the <select> element from which the user chooses locations for
# us to filter on.
sub PrintLocationsSelectElem {
	my $rPageState = TheBwdPageState::GetC();
	my $LocType    = BwdPageState::LocType( $rPageState );

	# The name of the select element, and thus the names of the URL parameters
	# it submits, depends on the location-type URL param.
	print( "<select name='$LocType' size='10' multiple='multiple'
														style='width:15em'>\n");

	# I'm not seeing any reason we need to submit an All option explicitly, and
	# it will make param handling simpler without it, so use value=''.  The only
	# reason we need an All option in the list at all is for users who don't
	# understand that they can deselect all other items to get all forests.
	print( "<option value=''>[All]</option>\n" );

	# Reselect the listbox items which were specified as selected in our URL.
	# This is so the user can reuse/modify their last selection set without
	# starting over.
	
	if( "state" eq $LocType ) {		# -CMA 2013.11.18.
		# We include only the states that actually have projects in the DB (as
		# of 2013.08.05).
		my @c_States = (
				[ 'AR', "Arkansas" ],     [ 'AZ', "Arizona" ],
				[ 'CA', "California" ],   [ 'CO', "Colorado" ],
				[ 'FL', "Florida" ],      [ 'ID', "Idaho" ],
				[ 'KY', "Kentucky" ],     [ 'LA', "Louisiana" ],
				[ 'MI', "Michigan" ],     [ 'MN', "Minnesota" ],
				[ 'MO', "Missouri" ],     [ 'MS', "Mississippi" ],
				[ 'MT', "Montana" ],      [ 'NC', "North Carolina" ],
				[ 'ND', "North Dakota" ], [ 'NE', "Nebraska" ],
				[ 'NM', "New Mexico" ],   [ 'NV', "Nevada" ],
				[ 'OH', "Ohio" ],         [ 'OK', "Oklahoma" ],
				[ 'OR', "Oregon" ],       [ 'SC', "South Carolina" ],
				[ 'SD', "South Dakota" ], [ 'TN', "Tennessee" ],
				[ 'TX', "Texas" ],        [ 'UT', "Utah" ],
				[ 'VA', "Virginia" ],     [ 'WA', "Washington" ],
				[ 'WY', "Wyoming" ] );

		my @ReqStates = BwdPageState::States( $rPageState );
	
		for( @c_States ) {
			my $DispState = $_->[ 0 ] . " " . $_->[ 1 ];

			PrintPreselOption( $DispState, \@ReqStates, $_->[ 0 ] );
		}
	} elsif( "rgn" eq $LocType ) {	# -CMA 2013.11.18.
		# There really is no Region 7!  -CMA 2013.11.12.
		my @c_Rgns = (
				[ 1, "Northern" ],
				[ 2, "Rocky Mountain" ],
				[ 3, "Southwestern" ],
				[ 4, "Intermountain" ],
				[ 5, "Pacific Southwest" ],
				[ 6, "Pacific Northwest" ],
				[ 8, "Southern" ],
				[ 9, "Eastern" ] );

		my @ReqRegions = BwdPageState::Regions( $rPageState );

		for( @c_Rgns ) {
			my $DispRgn = "Region " . $_->[ 0 ] . " (" . $_->[ 1 ] . ")";

			PrintPreselOption( $DispRgn, \@ReqRegions, $_->[ 0 ] );
		}
	} else {	# Forests.
		my @ReqForests = BwdPageState::Forests( $rPageState );
	
		my $rStupid = \@BwdQuery::c_Forests;	# Suppress only-once warning.
		PrintPreselOption( $_->[ 0 ], \@ReqForests ) for @BwdQuery::c_Forests;
	}

	# Tested by Test140130_1708.  -CMA 2014.01.30.
	print( "</select>\n");
}	# Bwd::PrintLocationsSelectElem.  -CMA 2013.08.06.

###############################################################################
# SUB:  Bwd::PrintOnLoadFunc.
sub PrintOnLoadFunc { my ( $bMapView, $raProjs ) = @_;
	print( "
function onLoad() {
	// CMA deleted 2013.11.26.  This worked around an IE bug which seems to
	// be gone now.
	/*divDescr.style.display='block';*/
	" );

	print( "onLoadMapView();\n" ) if $bMapView;
	print( "}\n" );
}	# Bwd::PrintOnLoadFunc.  -CMA 2013.12.31.

###############################################################################
# SUB:  Bwd::PrintOnLoadMap.

# NOTES:  The Javascript onLoadMapView() function generated by this Perl sub is
# only needed, and only works, in map view, so this Perl sub should only be
# called in map view.
sub PrintOnLoadMap { my ( $raProjs ) = @_;
	my $rPageState = TheBwdPageState::GetC();

	# Our map event callbacks, e.g. onMapZoom(), set these URL params.

	my $ScrollY = CGI::url_param( "scrollY" );

	# Avoid error log warning from expanding null in string.   -CMA 2014.02.04.
	$ScrollY = "" unless defined( $ScrollY );

	my $Zoom = CGI::url_param( "mapZoom" );

	# Default zoom = 4 shows the whole USA.
	$Zoom = 4 unless length( $Zoom );

	my $MapLat = CGI::url_param( "mapLat" );

	# Default center:  Center of the USA.

	$MapLat = 40 unless length( $MapLat );

	my $MapLon = CGI::url_param( "mapLon" );

	$MapLon = -100 unless length( $MapLon );

	# For the user's selected projects, generate the JavaScript literal data for
	# the markers to be shown on the map.  We insert this literal into the
	# Javascript below so that the Javascript code can access it.
	my $rPoints    = ProjectsPoints::New( $raProjs, $Zoom );
	my $MarkerData = ProjectsPoints::GetMarkersJs( $rPoints );

	# Tested by Test140206_1158.  -CMA 2014.02.07.
	print( "
function onLoadMapView() {
	var sScrollY = '$ScrollY';

	// When a user-click on the map makes us reget the page, we send scrollY,
	// and then use it here to preserve the scroll position.
	if( sScrollY.length > 0 )
		scrollTo( 0, sScrollY );

	var c_llMapCenter = new google.maps.LatLng( $MapLat, $MapLon );
	var c_map_type    = google.maps.MapTypeId.ROADMAP;

	var c_oMapOpts =
				{ center: c_llMapCenter, zoom: $Zoom, mapTypeId: c_map_type };

	var /*MarkerData[]*/ c_arrMarkerData = $MarkerData;

	// Show the Google Map in our <divMap> div.
	var divMap = document.getElementById( 'divMap' );
	var map    = new google.maps.Map( divMap, c_oMapOpts );

	for( var i = 0; i < c_arrMarkerData.length; i++ )
	{
		var /*LatLng*/ lat_lng = c_arrMarkerData[ i ].lat_lng;
		var sTitle             = c_arrMarkerData[ i ].title;
		var oMarkerOpts        = { position: lat_lng, map: map, title: sTitle };
		var marker             = new google.maps.Marker( oMarkerOpts );

		// This is our own field we add to the marker object, so our callback
		// can get the projects associated with this marker.
		marker.projs = c_arrMarkerData[ i ].projs;

		google.maps.event.addListener( marker, 'click', onMarkerClick );
	}

	google.maps.event.addListener( map, 'zoom_changed', onMapZoom );
}	// onLoadMapView().
	" );
}	# Bwd::PrintOnLoadMap.  -CMA 2013.12.31.

###############################################################################
# SUB:  Bwd::PrintPageNavCtrls.

# NOTES:  Prints our goto-previous-page, goto-next-page, and goto-report-number
# controls (actually 3 little forms).
sub PrintPageNavCtrls { my ( $raProjs ) = @_;
	my $rPageState   = TheBwdPageState::GetC();
	my $CurStart     = BwdPageState::PageStart( $rPageState );
	my $PerPage      = BwdPageState::PerPage( $rPageState );

	# Generate the previous-page form.

	my $PrevInputs   = "";
	my $PrevDisabled = "";

	if( $CurStart - $PerPage >= 1 ) {
		my $rPrevState = BwdPageState::Copy( $rPageState );
	
		BwdPageState::SetPageStart( $rPrevState, $CurStart - $PerPage );

		my @PrevParams = BwdPageState::Params( $rPrevState );

		$PrevInputs = ParamsToHiddenInputs( \@PrevParams );
	}
	else {
		$PrevDisabled  = "disabled='disabled'"; }
	
	print( "
<form method='get' style='display:inline'>
	$PrevInputs
	<button type='submit' $PrevDisabled>Previous $PerPage Reports</button>
</form>
	" );

	# Generate the next-page form.

	my @Params     = TheBwdPageState::NextPageParams();
	my $NextInputs = ParamsToHiddenInputs( \@Params );
	my $NextStart  = TheBwdPageState::NextStartNum();
	my $Disabled   = $NextStart > @$raProjs ? "disabled='disabled'" : "";

	# Using Get method so that the params appear in the URL, which lets
	# users save the URL to repeat the search.  Note that this could fail due to URL
	# length if the user selects too many params; a rarely-expected case which I
	# won't try to handle until the need is shown.
	print( "
<form method='get' style='display:inline'>
	$NextInputs
	<button type='submit' $Disabled>Next $PerPage Reports</button>
</form>
	" );

	# Print "go to report #" controls.  -CMA 2013.11.08.

	# Get a copy of the current page state...
	my $rGotoState = BwdPageState::Copy( $rPageState );

	# Reset the copy's page_start param.  This is a bit of a hack to remove the 
	# param from BwdPageState::Params()'s results below, because the text input
	# will provide the page_start param instead.
	BwdPageState::SetPageStart( $rGotoState, 0 );

	print( "&nbsp;&nbsp;&nbsp;&nbsp;
<form method='get' style='display:inline'>\n" . 
	ParamsToHiddenInputs( [ BwdPageState::Params( $rGotoState ) ] ) . "
	<button type='submit'>Go to report #:</button>
	<input type='text' name='page_start' style='width:3em'/>
	of " . @$raProjs . "
</form>
	" );
}	# Bwd::PrintPageNavCtrls.  -CMA 2013.08.20.

###############################################################################
# SUB:  Bwd::PrintPageStyle.
sub PrintPageStyle {
	print( "
<style type='text/css'>
	/* So the black left border overrides the light horizontal row
		border at the corners.  Works on Chrome, not IE 8. */
	.LeftCell    { border-left:1px solid black; }
	
	.NumCell     { text-align:right; padding-right:0.5em; }
	
	/* Note that border-radius doesn't work on IE 8. */
	.ProjectCell { border:1px solid black; padding:5px 10px;
						background-color:#ffffff; border-radius:10px }
														
	.RightCell   { border-right:1px solid black; } /* See .LeftCell. */
	.Sep         { border-top:1px solid #d2d5b2; }

/* No longer used.  -CMA 2014.01.13. */
/*		.Span300     { display:inline-block; width:300px; }	*/

	.SpanIndent  { display:inline-block; width:20px; }
	.SpanLabel   { display:inline-block; width:70px; }

	/* This must be wide enough for the vals in our totals-over-all-
	projects report. */
	.SpanNum { display:inline-block; width:9em; text-align:right; }
	
	/* -CMA 2014.01.13. */
	a.SortHeader { color:black; text-decoration:none; }
	a.SortHeader:hover { color:blue; }

	table { border-collapse:collapse; }
	td    { padding-left:0.5em; }
	th    { border:1px solid black; }
</style>
	" );
}	# Bwd::PrintPageStyle.  -CMA 2013.11.26.

###############################################################################
# SUB:  Bwd::PrintPreselOption.

# ACTION:  Shared code which generates an <option> element, preselected iff its
# value is found in a given list of (previously selected) values.

# PARAMS:  $SubmitValParam is optional; if missing, $DispVal becomes the
# "logical" submitted value.  $raSelVals is searched for the (logical)
# submitted value.
sub PrintPreselOption { my( $DispVal, $raSelVals, $SubmitValParam ) = @_;
	my $SubmitValLoc = $SubmitValParam ? $SubmitValParam : $DispVal;

	# Whether this option was previously selected.
	my $bReq = grep { $SubmitValLoc eq $_ } @$raSelVals;

	# If it was, then preselect it again.
	my $SelAttr = $bReq ? " selected='selected'" : "";

	my $ValAttr = $SubmitValParam ? " value='$SubmitValParam'" : "";

	print( "<option$SelAttr$ValAttr>$DispVal</option>\n" );
}	# Bwd::PrintPreselOption.  -CMA 2013.08.05.

###############################################################################
# SUB:  Bwd::PrintPresentationOptions.

# ACTION:  Prints the section of our Search form where the user chooses how to
# get his results:  list view or map view, with sub-options.
sub PrintPresentationOptions {
	my $rPageState = TheBwdPageState::GetC();
	my $bMap       = BwdPageState::IsMapView( $rPageState );

	# Preselect list or map view.
	my $ListViewCheckedAttr = $bMap ? "" : " checked='checked'";
	my $MapViewCheckedAttr  = $bMap ? " checked='checked'" : "";
	my $ListDisplayStyle    = $bMap ? "; display:none" : "";

	print( "
<div style='float:left'><!-- divPresOptions. -->
<b>Choose how to view your reports:</b><br />

<script type='text/javascript'>
	// Show the list-view sub-options only when the user selects list view.  I
	// would disable & gray these like in Windows instead of hiding them, but
	// CSS doesn't do that.
	function onViewButtonClick( input )
	{
		var vSubsStyle = document.getElementById( 'divListSubcontrols' ).style;

		vSubsStyle.display = ( input.value == 'map' ? 'none' : '' );
	}
</script>

<!-- divPresentationBox:  Create a border around the view options. -->
<div style='border:2px groove #e0e0c0; padding:1em; width:24em;
															margin-right:2em'>
  <input type='radio' name='view' value=''$ListViewCheckedAttr
						onclick='onViewButtonClick( this )'>List view</input>

  <!-- Sub-options of List View. -->
  <div id='divListSubcontrols' style='margin-left:2em$ListDisplayStyle'>
	" );

	PrintSortOptions();	# -CMA 2013.08.26.

	# Let user choose # of reports per page.

	print( "Show
		<select name='pp' size='1'>\n" );

	my $PerPage = BwdPageState::PerPage( $rPageState );

	for ( 10, 20, 50, 100, 200, 500, 1000, 2000 ) {
		# Preselect existing pp.
		my $SelAttr = $PerPage == $_ ? " selected='selected'" : "";

		print( "<option$SelAttr>$_</option>\n" );
	}

	print( "</select>
	reports per page
  </div><!-- End divListSubcontrols. --><br />
  <input type='radio' name='view' value='map'$MapViewCheckedAttr
							onclick='onViewButtonClick( this )'>Map view</input>
  <br />
</div><!-- End divPresentationBox. --><br />
</div><!-- End divPresOptions. -->
	" );
	# Tested by Test140205_1523.  -CMA 2014.02.05.
}	# Bwd::PrintPresentationOptions.  -CMA 2014.01.06.

###############################################################################
# SUB:  Bwd::PrintResults.
# ACTION:  Shows the search results.
# PARAMS:  $raProjs can be a filtered array, not necessarily the whole DB.
sub PrintResults { my ( $raProjs ) = @_;
	my $rPageState = TheBwdPageState::GetC();

	PrintFoundProjsDescr( $raProjs );	# -CMA 2013.08.06.
	print( "<br />" );

	# If the search is empty, then we already showed "Found 0 reports" above.
	# Stop before showing "Showing reports 1-0".  If a power user entered a
	# too-high start point in the URL, then he can live with the odd result.
	return unless @$raProjs;

	unless( BwdPageState::IsMapView( $rPageState ) ) {
		ShowProj::PrintListView( $raProjs );
		return;
	}

	# The rest of this sub shows the map view.

	# This div shows our Google Map; it gets filled by Javascript code.
	print( "\n<div id='divMap' style='width:600px; height:400px'></div>
																	<br />\n" );

	my @Handles = BwdPageState::ProjectHandles( $rPageState );

	# Show any projects below the map that are requested (by the user clicking
	# on a marker). 
	if( @Handles ) {
		# If we're showing projects, then we also show the toggle-units command.
		print( "<div style='text-align:right'>" . BwdQuery::GetUnitsRelink() .
																		"</div>
		" );

		for( @Handles ) {
			ShowProj::ShowProjectBlock( TheProjs::FromHandle( $_ ) ); }
	} else {
		#If we're not showing projects below the map, then use that space to
		# tell the user that he can do so.
		print( "Click on a marker in the map to get its report(s)." ); }
}   # Bwd::PrintResults.  -CMA 2014.01.06.

###############################################################################
# SUB:  Bwd::PrintSelectedItemsLine.
sub PrintSelectedItemsLine { my( $Label, $raSel ) = @_;
	print( "<span class='SpanIndent'></span><b>$Label:</b>\n" );

	# The next few lines will build in here, from the requested items,
	# the list of items we say we're showing.
	my @ListToPrint;

	# If no specific item was requested, then we show [All].
	if( !@$raSel ) {
		push( @ListToPrint, "[All]" ); }
	else {
		for( @$raSel ) {
			push( @ListToPrint, $_ ); } }

	# Now print the list of items, comma-separated.
	for( 0 .. $#ListToPrint - 1 ) {
		print( $ListToPrint[ $_ ] . ", "); }

	print( $ListToPrint[ $#ListToPrint ] . "<br />\n" );
}	# Bwd::PrintSelectedItemsLine.  -CMA 2013.08.01.

###############################################################################
# SUB:  Bwd::PrintSortOptions.
sub PrintSortOptions {
	my @c_SortVals = ( "", "cost", "dist", "name", "area", "forest" );

	my @c_SortOpts =
			( "most recent", "highest cost", "distance from:", "fire name",
														"largest", "forest" );

	my $rPageState = TheBwdPageState::GetC();
	my $CurSort    = BwdPageState::GetSortType( $rPageState );
	my $CurSortIdx = 0;		# An index into the above arrays.

	# Set $CurSortIdx.
	for ( 1..5 ) {
		if( $c_SortVals[ $_ ] eq $CurSort ) {
			$CurSortIdx = $_;
			last;
		} }

	my $bByDist = ( 2 eq $CurSortIdx );

	# The style to apply to elems which are specific to sort-by-location (this
	# hides those elems if sort-by-location is not the active sort type).
	my $LocStyleAttr = $bByDist ? "" : " style='display:none'";

	print( "
<script type='text/javascript'>

	// When the user clicks 'pick in map', this handler shows our location.pl
	// map popup.  location.pl will call this window's (index.pl's)
	// TakeDistOrigin() when the user clicks in the map.
	//
	// The size is tuned so the window fits tightly around the page contents.
	// There's no easy way to automate that, so it's easier to just hard-code
	// it.  -CMA 2013.11.25.
	function OnMapLinkClick()
			{ open( 'location.pl', '', 'width=320, height=330, status=no' ); }

	// When the user selects a different sort type, we must show/hide the
	// elements which only pertain to sort-by-distance.
	function OnSortSelChange( sel ) {
		var bDist = ( 2 == sel.selectedIndex );

		spanLatLon .style.display = bDist ? 'inline' : 'none';
		spanMapLink.style.display = bDist ? 'inline' : 'none';
	}

</script>

Order by 
<!-- This is the dropdown list which lets the user choose which type of sort to
	use. -->
<select name='sort' size='1' onchange='OnSortSelChange( this )'>
	" );

	# Print the sort-type choices.
	for ( 0..5 ) {
		# Preselect the user's existing sort type.
		my $SelAttr = ( $_ == $CurSortIdx ? " selected='selected'" : "" );

		print( "<option value='" . $c_SortVals[ $_ ] . "'$SelAttr>" .
											$c_SortOpts[ $_ ] . "</option>\n" );
	}

	# Distance-sort-specific elements.  Note that <spanMapLink> contains a <br>
	# because when it appears, we need a following blank line to separate it
	# from "Show XXX reports per page".  -CMA 2014.01.06.
	print( "
</select><br />
<span id='spanLatLon' $LocStyleAttr>\n" . 
								GetLatLonInputsHtml() . "\n</span>&nbsp;&nbsp;
<span id='spanMapLink' $LocStyleAttr><a
				href='JavaScript:OnMapLinkClick()'>pick in map</a><br /></span>
<br />
	" );
}	# Bwd::PrintSortOptions.  -CMA 2013.11.12.

###############################################################################
# SUB:  Bwd::PrintTreatmentsSelectDiv.

# ACTION:  Prints the section of our Search form where the user selects
# treatment types to filter on.
sub PrintTreatmentsSelectDiv {
	print( "
		<div style='float:left; margin-right:20px'>
			Treatment Types:<br />
			<select name='tmt' size='10' multiple='multiple' style='width:20em'>
	");

	# The set of treatment types which the user has selected before, and are
	# therefore stored in our page state.
	my @ReqTmts = TheBwdPageState::RequestedTreatments();

	print( "<option value=''>[All]</option>\n" );

	# CMA replaced 2014.01.16.
#	my $c_TmtCatsPath = "<DOCUMENT_ROOT>/BAERTOOLS/baer-db/Treatments.xml";
#	my $rTmtCatsXml = XML::Simple::XMLin( $c_TmtCatsPath );

	# Collect the treatment types from our DB's treatment types table in here.
	my @TmtTypes;

	my $rStupid = $ShowProj::raTmtTypesRowsXml;		# Kill only-once warning.
	for( @$ShowProj::raTmtTypesRowsXml ) {
		push( @TmtTypes, $_->{treatment} ); }

	# Print the select-list option for each treatment type.
	for( BwdUtils::SortAlpha( \@TmtTypes ) ) {
		PrintPreselOption( $_, \@ReqTmts ); }

	print( "</select>\n</div>\n");
}	# Bwd::PrintTreatmentsSelectDiv.  -CMA 2013.08.28.

###############################################################################
# SUB:  Bwd::ShowBaerDbContent.
# ACTION:  Shows our page-specific content (as opposed to site-general content).
sub ShowBaerDbContent { my ( $raProjs ) = @_;
	# I placed this text in a div with an id (divDescr) so I could access it
	# from Javascript to work around an IE bug.  The bug seems to be gone now,
	# but I'm leaving the scaffolding just in case.  -CMA 2013.11.26.
	print( "
<div id='divDescr'>
<b>BAER Burned Area Reports DB</b> is a database containing post-fire assessment
information from four decades of US Forest Service Burned Area Reports. For more
information and help, see
<a href='guide.pl'>BAER Burned Area Reports DB Guide</a>.<br />
<br />
</div>
	" );

	ShowSearchForm();
	print( "<br style='clear:both' /><hr /><br />" );
	PrintResults( $raProjs );

	# Page nav controls are only relevant in list view, since we have the page 
	# concept only in list view.  Tested by Test140204_0938.  -CMA 2014.02.04.
	unless( BwdPageState::IsMapView( TheBwdPageState::GetC() ) ) {
		PrintPageNavCtrls( $raProjs ); }
}	# Bwd::ShowBaerDbContent.  -CMA 2013.07.19.

###############################################################################
# SUB:  Bwd::ShowSearchForm.
sub ShowSearchForm { 
	# Using Get method so that the params appear in the URL, which lets users
	# save the URL to repeat the search.  Note that this could fail due to URL
	# length if the user generates too many params; a rarely-expected case which
	# I won't try to handle until the need is shown.
	print( "
<form method='get'>
	<b>Select which reports you want:</b><br />

	<!-- divFilters. -->
	<div style='border:2px groove #e0e0c0; padding:1em; width:43em'>
	" );

	PrintLocationsSelectDiv();
	PrintTreatmentsSelectDiv();		# -CMA 2013.08.19.
	print( "<br style='clear:both' /><br />\n" );
	PrintDatesInputLine();	# -CMA 2013.08.26.
	print( "</div><!-- End divFilters. --><br />" );
	PrintPresentationOptions();		# -CMA 2014.01.06.

	my @HiddenParams = BwdPageState::HiddenParams( TheBwdPageState::GetC() );

	print( ParamsToHiddenInputs( \@HiddenParams ) );

	print( "
		<b>And finally:</b><br />
		<button type='submit' style='width:8em'><b>Get reports</b></button>
	</form>
	" );
}	# Bwd::ShowSearchForm.  -CMA 2013.11.13.

}	# End package Bwd.

###############################################################################
###############################################################################
# PACKAGE:  ProjectsPoints.  -CMA 2014.01.03.

# A "class" which stores a collection of lat/lon points and, for each point, a
# collection of projects associated with that point.

# Like all of our "objects", this one is an array ref; but unlike most, the
# ProjectsPoints array is not of "fields" with fixed meanings at fixed indexes.
# Rather, the ProjectsPoints array is, directly, an array of "PointProjs" object
# refs.  And each PointProjs ref is, directly, an array of BaerProj refs.  Each
# PointProjs contains at least one project, and the latlon of the first project
# in the PointProjs is used as the latlon for the whole group.
{	package ProjectsPoints;

###############################################################################
# SUB:  ProjectsPoints::GetMarkersJs.

# ACTION:  Generates a JavaScript data literal containing the data our JS code
# (onLoadMapView()) uses to create the markers representing this ProjectsPoints
# on the map in map view.
sub GetMarkersJs { my( $this ) = @_;
	my $Ret  = "[\n";
	my $b1st = 1;

	for my $rPointProjs ( @$this ) {

		# CMA deleted 2014.01.08.
#		my $MarkerJs = Bwd::GetMarkerDataJs( $rPointProjs );
#		next unless $MarkerJs;	# Some projects have no location data.

		$Ret .= ", " unless $b1st;
		$Ret .= _GetMarkerDataJs( $rPointProjs );
		$b1st = 0;
	}

	return $Ret . "\n]";
}	# ProjectsPoints::GetMarkersJs.  -CMA 2014.01.03.

###############################################################################
# SUB:  ProjectsPoints::New.

# ACTION:  Creates a ProjectsPoints by grouping the given projects such that
# projects which are too geographically close for their markers to be
# distinguished on a map, are grouped onto the same point.
sub New { my( $raProjs, $iZoom ) = @_;
	my @This;	# We'll add PointProjs groups to this empty array.

Outer:
	# Each iteration takes the next given project, and either adds it to an
	# already-created PointProjs group if it's geographically near such a group,
	# or else creates a new group for it.
	for my $rProjToAdd ( @$raProjs ) {
		my $NewLat = BaerProj::Lat( $rProjToAdd );
		my $NewLon = BaerProj::Lon( $rProjToAdd );

		# Some projects have no location fields, so can't be grouped by
		# location.
		next unless length( $NewLat ) && length( $NewLon );

		# Check our already-created PointProjs groups for one near this project.
		for my $rExistingPt ( @This ) {
			# For the existing group's location, we use its first project's
			# location (since all of the projects in a group are near each
			# other).
			my $LatDiff = BaerProj::Lat( $rExistingPt->[ 0 ] ) - $NewLat;

			# Same conversion as longitude below.  This is not quite right
			# because map distance of a latitude difference increases poleward
			# on a Mercator map, but the scale factor is < 1.5 at our latitudes
			# and we can tweak the threshold below for it anyway if we want.
			my $PixDiffY = $LatDiff * ( 256 / ( 2 * 3.14 ) ) * ( 2 << $iZoom );

			# If this project is far enough (in either X or Y, with below test)
			# from this group, then it doesn't need to be added to this group;
			# move on and check the next group.  I tuned these threshold values
			# visually, checking that on a crowded map, markers were close but
			# not too close to each other.  I figure the hand-coded test against
			# + and - here probably runs quicker than calling an Abs() routine.
			next if $PixDiffY > 6 || $PixDiffY < -6;

			my $LonDiff = BaerProj::Lon( $rExistingPt->[ 0 ] ) - $NewLon;

			# Longitude diff to pixels is actually the same at all latitudes on
			# a Mercator map.  The conversion factor equates the 256-pixel
			# whole-world Google base map to 2*pi radians, x 2 for each Google
			# zoom level.  From Google Maps API > Map Types > World Coordinates.
			my $PixDiffX = $LonDiff * ( 256 / ( 2 * 3.14 ) ) * ( 2 << $iZoom );

			# This X threshold could be different than the Y (it's just a visual
			# factor), but doesn't seem to want to be.
			next if $PixDiffX > 6 || $PixDiffX < -6;

			# If here, then the project wasn't far enough away from this group,
			# so add it to this group.
			push( @$rExistingPt, $rProjToAdd );

			# We certainly don't want to add this project to more than one
			# group, so now that we just added it to this group, move on to the
			# next project.
			next Outer;
		}

		# If here, then we checked this project against all existing groups and
		# it didn't belong in any of them, so create a new group for this
		# project.
		my @NewPointProjsObj;

		$NewPointProjsObj[ 0 ] = $rProjToAdd;
		push( @This, \@NewPointProjsObj );
	}

	return \@This;
}	# ProjectsPoints::New.  -CMA 2014.01.03.

###############################################################################
# SUB:  ProjectsPoints::_GetMarkerDataJs.

# ACTION:  Generates a JavaScript data literal containing the data our JS code
# (onLoadMapView()) uses to create a single marker on the map in map view.

# PARAMS:  $raProjs is the array of projects (usually one, but up to several)
# which we're putting on the same marker (because they're too close for separate
# markers).
sub _GetMarkerDataJs { my( $raProjs ) = @_;
	# Since the projects are very near each other on the map, we can just use
	# the 1st one's location for the marker's location.  Note that we already
	# skipped locationless projects when we created "this", so this lat & lon
	# should always be good.
	my $Lat = BaerProj::Lat( $raProjs->[ 0 ] );
	my $Lon = BaerProj::Lon( $raProjs->[ 0 ] );

	# Convert latlon from NW radians to Google format.
	$Lat *=  57.295779513;
	$Lon *= -57.295779513;

	# The marker title will be a string for each project, separated by \n's.
	my $Title = _GetProjDescriptionJs( $raProjs->[ 0 ] );

	# The <projs> field will be an array literal of project handles.
	my $Projs = "[ " . BaerProj::Handle( $raProjs->[ 0 ] );

	for( 1..$#{$raProjs} ) {
		# We're generating JS code, so we need the actual \n code, not a CR
		# char, in the string.
		$Title .= ( '\n' . _GetProjDescriptionJs( $raProjs->[ $_ ] ) );

		$Projs .= ( ", " . BaerProj::Handle( $raProjs->[ $_ ] ) );
	}

	$Projs .= " ]";

	# This is an "object" of our own Javascript MarkerData "type".
	# Tested by Test140206_1158.  -CMA 2014.02.06.
	return "\n{ lat_lng: new google.maps.LatLng( $Lat, $Lon ),
											title: '$Title', projs: $Projs }";
}	# ProjectsPoints::_GetMarkerDataJs.  -CMA 2014.01.01.

###############################################################################
# SUB:  ProjectsPoints::_GetProjDescriptionJs.

# ACTION:  Generates a short JavaScript string literal describing a single
# project.

# RETURN:  The returned string is not in quotes, because it's meant to be
# combined with other elements into a larger *single-quoted* JavaScript string
# literal.
sub _GetProjDescriptionJs { my( $rProj ) = @_;
	my $FireStrt = BaerProj::FireStrt( $rProj );

	# We have some missing FireStrt's in the DB, and substr() apparently crashes
	# on invalid args!
	my $Year = length( $FireStrt ) >= 4 ? substr( $FireStrt, 0, 4 ) : "";

	my $Firename = BaerProj::Firename( $rProj );

	# We're embedding this string in a single-quoted JS literal, so we must
	# escape any '.
	$Firename =~ s{'}{\\'}g;

	# One firename contains the Unicode apostrophe, so we generate a JS escape
	# for it.
	$Firename =~ s{\x{2019}}{\\u2019}g;

	# Remove everything we haven't decided to accept.  Probably don't need to do
	# this for current data, but it seems safest for future data.  This accepts
	# space, word chars (\w), '-' and '\', and any of [/,.'()&#?].  Note that we 
	# accept '\' because we inserted it as an escape above; we don't expect it
	# in user data and don't escape it properly in that case.
	$Firename =~ s{[^ \w\-\\/,.'()&#?]}{}g;

	return "$Year $Firename";
}	# ProjectsPoints::_GetProjDescriptionJs.  -CMA 2014.01.09.

}	# End package ProjectsPoints.

################################# END OF FILE #################################
